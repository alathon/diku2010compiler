%token <int*(int*int)> NUM
%token <(int*int)> TRUE FALSE
%token <(int*int)> LT GT EQUALS
%token <(int*int)> ELSE IN
%token <(int*int)> NOT AND OR
%token <string*(int*int)> NULL
%token <string*(int*int)> TYPE
%token <string*(int*int)> ID
%token <(int*int)> PLUS MINUS
%token <(int*int)> FUN LPAR RPAR ARROW
%token <(int*int)> END MATCHARROW
%token <(int*int)> INT BOOL BAR COLON
%token <(int*int)> COMMA SEMICOLON
%token <(int*int)> READ WRITE EOF
%token <(int*int)> AT
%token <(int*int)> LET CASE OF READ


%right BAR
%right MATCHARROW
%left PLUS MINUS
%nonassoc LT EQUALS
%right ELSE IN
%right OR
%right AND
%nonassoc NOT
%right WRITE

%start Prog
%type <Cat.Prog> Prog
%type <Cat.Type> Type
%type <Cat.Type list> Types
%type <Cat.Exp> Exp
%type <Cat.Exp list> Exps
%type <Cat.Match> Match
%type <Cat.Pat> Pat
%type <Cat.Pat list> Pats
%type <Cat.TyDec list> TyDecs
%type <Cat.FunDec list> FunDecs

%%

Prog :	 TyDecs FunDecs Exp EOF
	                { ($1,$2,$3) }
;

TyDecs  : TYPE ID EQUALS LPAR Types RPAR TyDecs
             { (#1 $2, $5, #2 $1) :: $7 }
        |    { [] }
;

FunDecs : FUN ID COLON Type ARROW Type Match END FunDecs
			{ (#1 $2, $4, $6, $7, $1) :: $9 }
	|		{ [] }
;


Type :	  INT		{ Cat.Int $1 }
        | BOOL          { Cat.Bool $1 }
        | ID            { Cat.TyVar $1 }
;

Types :   Type  { [$1] }
        | Type COMMA Types { $1 :: $3 }
;

Pat :	  NUM		{ Cat.NumP $1 }
        | TRUE          { Cat.TrueP $1 }
        | FALSE         { Cat.FalseP $1 }
        | NULL          { Cat.NullP (#2 $1) }
	| ID 		{ Cat.VarP $1 }

;

Pats :    Pat { [$1] }
        | Pat COMMA Pats      { $1 :: $3 }
;

Match :	  Pat MATCHARROW Exp
			{ [($1,$3)] }
	| Match BAR Match
			{ $1 @ $3 }
;

Exp :	  NUM		{ Cat.Num $1 }
        | TRUE          { Cat.True $1 }
        | FALSE         { Cat.False $1 }
        | NULL          { Cat.Null $1 }
	| ID		{ Cat.Var $1 }
	| Exp PLUS Exp	{ Cat.Plus ($1, $3, $2) }
	| Exp MINUS Exp	{ Cat.Minus ($1, $3, $2) }
        | Exp EQUALS Exp { Cat.Equal ($1, $3, $2) }
        | Exp LT Exp    { Cat.Less ($1, $3, $2) }
        | NOT Exp       { Cat.Not ($2, $1) }
        | Exp AND Exp   { Cat.And ($1, $3, $2) }
        | Exp OR Exp    { Cat.Or ($1, $3, $2) }




	| ID Exp %prec WRITE
			{ Cat.Apply (#1 $1, $2, #2 $1) }
	| READ		{ Cat.Read $1 }
	| WRITE Exp	{ Cat.Write ($2, $1) }
	| LPAR Exp RPAR	{ $2 }
;


Exps :  Exp { [$1] }
      | Exp SEMICOLON Exps { $1 :: $3 }
;
